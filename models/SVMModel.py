import torch
import torch.nn as nn
import torch.optim as optim
from tqdm import tqdm

class SVM(nn.Module):
    def __init__(self, num_classes, input_size):
        super(SVM, self).__init__()
        self.num_classes = num_classes
        self.W = nn.Parameter(torch.zeros(input_size, num_classes), requires_grad=True)
        self.b = nn.Parameter(torch.zeros(num_classes), requires_grad=True)
    
    def forward(self, x):
        scores = torch.matmul(x, self.W) + self.b
        return scores
    
    def hinge_loss(self, scores, y):
        correct_class_score = scores[torch.arange(y.shape[0]), y].unsqueeze(1)
        margins = torch.maximum(0, scores - correct_class_score + 1)
        margins[torch.arange(y.shape[0]), y] = 0
        loss = margins.mean()
        return loss
    
    def fit(self, dataloader, num_epochs=10, lr=0.001):
        criterion = self.hinge_loss
        optimizer = optim.SGD(self.parameters(), lr=lr)
        
        for epoch in range(num_epochs):
            running_loss = 0.0
            for inputs, labels in tqdm(dataloader):
                optimizer.zero_grad()
                scores = self(inputs)
                loss = criterion(scores, labels)
                loss.backward()
                optimizer.step()
                running_loss += loss.item()
            epoch_loss = running_loss / len(dataloader)
            print('Epoch {}/{} loss: {:.4f}'.format(epoch+1, num_epochs, epoch_loss))
