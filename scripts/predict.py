import torch
import torch.nn as nn
import torch.nn.functional as F
import numpy as np
from torch.optim.lr_scheduler import ExponentialLR, StepLR
from torch.optim import SGD, Adam
from models.cnnmodels import VGG16, ResNet50, GoogLeNet, DenseNet121, ShuffleNet
from utils.utils import fix_seed, log
from sklearn.metrics import confusion_matrix
from sklearn.linear_model import LogisticRegression
from PIL import Image
Image.MAX_IMAGE_PIXELS = None
from utils.bin2img import bin_to_gray_image, bin_to_dct_image, bin_to_rgb_image, bin_to_gray_image_exclude_rsrc
from utils.utils import is_pe_file
import os
from torchvision import transforms as T
import pickle

class Predicter(object):
    def __init__(self, cfgs):
        fix_seed(cfgs['seed'])
        self.cfgs = cfgs
        self.class_names = os.listdir(self.cfgs['malimg_path'])

        self.vgg16 = VGG16(num_classes=cfgs["num_classes"])
        self.resnet50 = ResNet50(num_classes=cfgs["num_classes"])
        self.googlenet = GoogLeNet(num_classes=cfgs["num_classes"])
        self.densenet121 = DenseNet121(num_classes=cfgs["num_classes"])
        self.shufflenet = ShuffleNet(num_classes=cfgs["num_classes"])

        self.device = f'cuda:{cfgs["cuda_idx"]}' if (torch.cuda.is_available() and cfgs["cuda_idx"]>=0) else 'cpu'
        self.vgg16.to(self.device)
        self.resnet50.to(self.device)
        self.googlenet.to(self.device)
        self.densenet121.to(self.device)
        self.shufflenet.to(self.device)

        self.vgg16.load_state_dict(torch.load(f'{cfgs["save_model_path"]}/vgg16_best.pth'))
        self.resnet50.load_state_dict(torch.load(f'{cfgs["save_model_path"]}/resnet50_best.pth'))
        self.googlenet.load_state_dict(torch.load(f'{cfgs["save_model_path"]}/googlenet_best.pth'))
        self.densenet121.load_state_dict(torch.load(f'{cfgs["save_model_path"]}/densenet121_best.pth'))
        self.shufflenet.load_state_dict(torch.load(f'{cfgs["save_model_path"]}/shufflenet_best.pth'))

        self.vgg16.eval()
        self.resnet50.eval()
        self.googlenet.eval()
        self.densenet121.eval()
        self.shufflenet.eval()

        self.transforms = T.Compose([
            T.Resize((224, 224)),
            T.ToTensor(),
            T.Normalize([0.485, 0.456, 0.406], [0.229, 0.224, 0.225])
        ])

    def convert_image(self, file_path):
        algo = self.cfgs['algo']
        if algo in ['bin2gray', 'bin2dct', 'bin2grayexrsrc', 'bin2rgb']:
            img_path = f'./{os.path.basename(file_path)}.png'
            if self.cfgs['check'] and not is_pe_file(file_path):
                print(f"{file_path} is not a PE file!")
                raise NotImplementedError
            else:
                if algo == 'bin2gray':
                    bin_to_gray_image(file_path, img_path)
                elif algo == 'bin2dct':
                    bin_to_dct_image(file_path, img_path)
                elif algo == 'bin2grayexrsrc':
                    bin_to_gray_image_exclude_rsrc(file_path, img_path)
                elif algo == 'bin2rgb':
                    bin_to_rgb_image(file_path, img_path)
            return img_path
        else:
            raise NotImplementedError

    def predict_cnn(self, file_path, is_image=True):
        if not is_image:
            file_path = self.convert_image(file_path)
        
        image = Image.open(file_path).convert("RGB")
        image = self.transforms(image).unsqueeze(0).to(self.device)
        with torch.no_grad():
            if self.cfgs['model'] == 'vgg16':
                output = self.vgg16(image)
            elif self.cfgs['model'] == 'resnet50':
                output = self.resnet50(image) 
            elif self.cfgs['model'] == 'googlenet':
                output = self.googlenet(image)
            elif self.cfgs['model'] == 'densenet121':
                output = self.densenet121(image)
            elif self.cfgs['model'] == 'shufflenet':
                output = self.shufflenet(image)
            else:
                raise NotImplementedError
            probabilities = F.softmax(output, dim=1)

        _, predicted_class = torch.max(probabilities, 1)
        predicted_class_idx = predicted_class.item()

        predicted_class_name = self.class_names[predicted_class_idx]
        print(predicted_class_name)

    def predict_ensemble(self, file_path, is_image=True):
        if not is_image:
            file_path = self.convert_image(file_path)

        image = Image.open(file_path).convert("RGB")
        image = self.transforms(image).unsqueeze(0).to(self.device)
        with torch.no_grad():
            vgg16_outputs = F.softmax(self.vgg16(image), dim=1)
            resnet50_outputs = F.softmax(self.resnet50(image), dim=1)
            googlenet_outputs = F.softmax(self.googlenet(image), dim=1)
            densenet_outputs = F.softmax(self.densenet121(image), dim=1)
            shufflenet_outputs = F.softmax(self.shufflenet(image), dim=1)

        if self.cfgs['model'] == 'majority_voting':
            with torch.no_grad():
                vgg16_preds = torch.argmax(vgg16_outputs, dim=1)
                resnet50_preds = torch.argmax(resnet50_outputs, dim=1)
                googlenet_preds = torch.argmax(googlenet_outputs, dim=1)
                densenet_preds = torch.argmax(densenet_outputs, dim=1)
                shufflenet_preds = torch.argmax(shufflenet_outputs, dim=1)

                all_preds = torch.stack([vgg16_preds, resnet50_preds, googlenet_preds, densenet_preds, shufflenet_preds], dim=0)
                preds, _ = torch.mode(all_preds, dim=0)
                predicted_class_idx = preds.cpu().tolist()[0]

            predicted_class_name = self.class_names[predicted_class_idx]
            print(predicted_class_name)

        elif self.cfgs['model'] == 'distribution_summation':
            with torch.no_grad():
                all_preds = vgg16_outputs + resnet50_outputs + googlenet_outputs + densenet_outputs + shufflenet_outputs
                _, preds = torch.max(all_preds, dim=1)
                predicted_class_idx = preds.cpu().tolist()[0]

            predicted_class_name = self.class_names[predicted_class_idx]
            print(predicted_class_name)

        elif self.cfgs['model'] == 'bayesian_combination':
            vgg16_conf_matrix = np.load(f'{self.cfgs["save_data_path"]}/vgg16_val_conf_matrix.npy')
            resnet50_conf_matrix = np.load(f'{self.cfgs["save_data_path"]}/resnet50_val_conf_matrix.npy')
            googlenet_conf_matrix = np.load(f'{self.cfgs["save_data_path"]}/googlenet_val_conf_matrix.npy')
            densenet121_conf_matrix = np.load(f'{self.cfgs["save_data_path"]}/densenet121_val_conf_matrix.npy')
            shufflenet_conf_matrix = np.load(f'{self.cfgs["save_data_path"]}/shufflenet_val_conf_matrix.npy')

            vgg16_conf_matrix = vgg16_conf_matrix / vgg16_conf_matrix.sum(axis=1, keepdims=True)
            resnet50_conf_matrix = resnet50_conf_matrix / resnet50_conf_matrix.sum(axis=1, keepdims=True)
            googlenet_conf_matrix = googlenet_conf_matrix / googlenet_conf_matrix.sum(axis=1, keepdims=True)
            densenet121_conf_matrix = densenet121_conf_matrix / densenet121_conf_matrix.sum(axis=1, keepdims=True)
            shufflenet_conf_matrix = shufflenet_conf_matrix / shufflenet_conf_matrix.sum(axis=1, keepdims=True)

            vgg16_probs = torch.Tensor([vgg16_conf_matrix[i,i] for i in range(len(vgg16_conf_matrix))]).to(self.device)
            resnet50_probs = torch.Tensor([resnet50_conf_matrix[i,i] for i in range(len(resnet50_conf_matrix))]).to(self.device)
            googlenet_probs = torch.Tensor([googlenet_conf_matrix[i, i] for i in range(len(googlenet_conf_matrix))]).to(self.device)
            densenet121_probs = torch.Tensor([densenet121_conf_matrix[i, i] for i in range(len(densenet121_conf_matrix))]).to(self.device)
            shufflenet_probs = torch.Tensor([shufflenet_conf_matrix[i, i] for i in range(len(shufflenet_conf_matrix))]).to(self.device)

            with torch.no_grad():
                outputs = vgg16_outputs * vgg16_probs + resnet50_outputs * resnet50_probs + \
                    googlenet_outputs * googlenet_probs + densenet_outputs * densenet121_probs + \
                        shufflenet_outputs * shufflenet_probs
                _, preds = torch.max(outputs, dim=1)
                predicted_class_idx = preds.cpu().tolist()[0]

            predicted_class_name = self.class_names[predicted_class_idx]
            print(predicted_class_name)

        elif self.cfgs['model'] == 'stacking':
            with open(f'{self.cfgs["save_model_path"]}/stacking_meta_model.pkl', 'rb') as f:
                meta_model = pickle.load(f)

            new_features = np.hstack((vgg16_outputs, resnet50_outputs, googlenet_outputs, densenet_outputs, shufflenet_outputs))
            predicted_labels = meta_model.predict(new_features)
            predicted_class_name = self.class_names[predicted_labels]
            print(predicted_class_name)
